<?xml version="1.0" encoding="UTF-8"?>
<skeletons>

  <!-- comment TYPEDEF -->
  <skeleton name="TYPEDEF">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.TypeDefinition"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="comment"></pattern>
    </patterns>
  </skeleton>

  <!-- replace TYPE BOOL declarations -->
  <skeleton name="BOOL.DECLARE" var="level,name">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.DataDescription" type="BOOL"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="replace">
%level  %name-value PIC X VALUE LOW-VALUE.
    88  %name       VALUE 'T'.
    88  %name-false VALUE 'F'.
      </pattern>
    </patterns>
  </skeleton>

  <!-- delete and replace TYPE -->
  <skeleton name="TYPE">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.DataDescription" type="*"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="expand"></pattern>
    </patterns>
  </skeleton>

  <!-- replace SET <boolean> TO FALSE -->
  <skeleton name="BOOL.SET" var="receiver">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.Set" sender.type="BOOL" sender="FALSE"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="replace">
        SET %receiver-false TO TRUE.
      </pattern>
    </patterns>
  </skeleton>

  <!-- delete UNSAFE -->
  <skeleton name="UNSAFE">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeElements.VariableWriter" unsafe="true"/>
    </conditions>
    <patterns>
      <pattern location="NODE" action="erase">UNSAFE</pattern>
    </patterns>
  </skeleton>

  <!-- replace DECLARE FUNCTION PUBLIC by a stacked program -->
  <skeleton name="FUN.DECLARE.PUBLIC" var="definitions">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="public" />
    </conditions>
    <patterns>
      <pattern location="program.data-division.linkage" action="create" group="TCRFUN_CODEGEN_CALLS_ARRAY">
01  FctList.
    05 NumberOfFunctions   PIC 9(04).
    05 FctItem OCCURS 9999 DEPENDING ON NumberOfFunctions
                           INDEXED BY FctIndex.
      10 FctCode    PIC X(08).
      10 FctPointer PROCEDURE-POINTER VALUE NULL.
      </pattern>
      <pattern location="program.data-division.linkage" action="create" group="TCRFUN_CODEGEN_CALL_MODE">
01  CallData.
    05  DescriptionId PIC X(08).
      88 CallIsCopy VALUE 'TODO'.
      </pattern>
      <pattern location="program.data-division.working-storage" action="create" group="TCRFUN_CODEGEN_IS_LOADED">
01  LibFctList-Loaded PIC X(01) VALUE SPACE.
    88 LibFctList-IsLoaded      VALUE '1'.
      </pattern>
      <pattern location="program.data-division.working-storage" action="create" group="TCRFUN_CODEGEN_POINTER_ARRAY">
@{
  var items = "";
  foreach (var f in %definitions.functions.Public) {
    items += "*    "+f.Label+" -> "+f.Name+'\n';
    items += "    05 PIC X(08) VALUE \'"+f.Label+"\'.\n";
    items += "    05 PIC X(08) VALUE LOW-VALUES.\n";
  }
}
01  LibFctList-VALUES.
@items
      </pattern>
      <pattern location="program.data-division.working-storage" action="create" group="TCRFUN_CODEGEN_REDEFINED_ARRAY">
01  LibFctList REDEFINES LibFctList-Values.
    05   LibFctItem    OCCURS %definitions.functions.Public.Count INDEXED BY LibFctIndex.
      10 LibFctCode    PIC X(08).
      10 LibFctPointer PROCEDURE-POINTER.
      </pattern>
      <pattern action="expand" location="program.end"></pattern>
      <pattern location="program.procedure-division.begin" action="create" group="TCRFUN_CODEGEN_ADAPTABLE_BEHAVIOUR">
    IF CallIsCopy
      PERFORM Copy-Process-Mode
    ELSE
      PEFORM FctList-Process-Mode
    END-IF

    GOBACK
      </pattern>
      <pattern location="program.procedure-division" action="replace" group="TCRFUN_CODEGEN_PROCEDURE_USING">
PROCEDURE DIVISION USING CallData.
      </pattern>
    </patterns>
  </skeleton>
  <!-- replace DECLARE FUNCTION PRIVATE by a stacked program -->
  <skeleton name="FUN.DECLARE.PRIVATE" var="definitions">
    <conditions>
      <condition node="TypeCobol.Compiler.Nodes.FunctionDeclaration" visibility="private" />
    </conditions>
    <patterns>
      <pattern action="expand" location="program.end"></pattern>
    </patterns>
  </skeleton>

  <!-- replace function invocation by a CALL and create utility variables -->
  <skeleton name="FUN.CALL" var=" function  ,receiver ">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeElements.VariableUser" function="*"/>
    </conditions>
    <patterns>
      <pattern location="data-division.working-storage" action="create" group="%function.Library-VARS" var="function=$function">
01 %function.Copy COPY %function.Copy.
01 %function.Library PIC X(08) VALUE '%function.Library'.
      </pattern>
      <pattern location="data-division.working-storage" action="create" group="functions">
01 ERROR-CODE PIC X(08).
      </pattern>
      <!--pattern location="data-division.working-storage" action="create" group="%function.Name" var="type=$function.Result.Definition">
01 %function.Name-RESULT %function.Result.Definition.
      </pattern-->
      <pattern location="procedure-division.begin" action="create" group="%function.Library-CALL">
    IF %function.Copy-POINTER-TABLE = LOW_VALUE
        CALL %function.Library USING %function.Copy
    END-IF
      </pattern>
      <pattern location="NODE" action="replace">
@{
  var funparams = "";
  foreach (var p in %function.InputParameters) {
    funparams += "        BY " + p.SendingMode + " " + p.Value + "\n";
  }
}
    CALL %function.Name USING
@funparams
        BY REFERENCE %function.Name-RESULT
        BY REFERENCE ERROR-CODE

    IF ERROR-CODE = ZERO
        MOVE %function.Name-RESULT TO %receiver
    ELSE
*    TODO: error management
    END-IF
      </pattern>
    </patterns>
  </skeleton>

  <!-- replace "::" qualification by "OF" inverse qualification -->
  <skeleton name="QUALIFICATION">
    <conditions>
      <condition node="TypeCobol.Compiler.CodeElements.VariableUser" variables.typecobol="+"/>
    </conditions>
    <patterns>
      <pattern action="expand" location="NODE"></pattern>
    </patterns>
  </skeleton>

</skeletons>