namespace TypeCobol.Compiler.CupPreprocessor;

using TUVienna.CS_CUP.Runtime;
using System;
using System.Collections;
using System.Collections.Generic;
using TypeCobol.Compiler.CupCommon;
using TypeCobol.Compiler.Scanner;

action code {:
:};

parser code {:
	// The Compiler Directive Builder instance.
	public ICompilerDirectiveBuilder Builder
	{
		get;
		set;
	}
	// The Error Reporter instance
	public ICupParserErrorReporter ErrorReporter
	{
		get;
		set;
	}

	// Test wheither or not this parser is a trial parser
	public bool IsTrial
	{
		get;
		set;
	}

  // get the current state of the parser.
  public int getParserState() 
  {
	return ((Symbol)stack.Peek()).parse_state;	
  }

  //get the parser stack.
  public Stack getParserStack() 
  {
	return stack;	
  }

  public override void report_fatal_error(
    string   message, 
    object   info)
	{
		if(ErrorReporter != null) {
			if (ErrorReporter.ReportFatalError(this, message, info))
			{
				return;
			}
		}
		base.report_fatal_error(message, info);
	}

	public override void report_error(string message, object info)
	{
		if(ErrorReporter != null) {
			if (ErrorReporter.ReportError(this, message, info))
			{
				return;
			}
		}
		base.report_error(message, info);
	}

	public override void syntax_error(Symbol cur_token)
	{
		if(ErrorReporter != null) {
			if (ErrorReporter.SyntaxError(this, cur_token))
			{
				return;
			}
		}
		base.syntax_error(cur_token);
	}

	public override void unrecovered_syntax_error(Symbol cur_token)
	{
		if(ErrorReporter != null) {
			if (ErrorReporter.UnrecoveredSyntaxError(this, cur_token))
			{
				return;
			}
		}
		base.unrecovered_syntax_error(cur_token);
	}
:};

// Include Cobol Words Symbols
#use ..\CupCommon\CobolWordsSymbols.cup
non terminal starts;
non terminal compilerDirectingStatement;
non terminal basisCompilerStatement;

// A typical COBOL compiler has a pre-step where comments and compiler directing 
// statements are processed to generate a source text suitable for subsequent parsing. 
// The "text manipulation" phase drops comment lines, processes continuation lines, 
// processes COPY directives and builds compiler directives to guide subsequent compilation.

start with starts;

#use ..\CupCommon\CobolWordsRules.cup


starts ::= compilerDirectingStatement
	;

// **************
// Step 4 : Compiler-directing statements

// p57: Compiler-directing statements
// Most compiler-directing statements, including COPY and REPLACE, can start in
// either Area A or Area B.
// BASIS, CBL (PROCESS), *CBL (*CONTROL), DELETE, EJECT, INSERT, SKIP1,
// SKIP2, SKIP3, and TITLE statements can also start in Area A or Area B.

// p527: A compiler-directing statement is a statement that causes the compiler to take a
// specific action during compilation.
// You can use compiler-directing statements for the following purposes:
// - Extended source library control (BASIS, DELETE, and INSERT statements)
// - Source text manipulation (COPY and REPLACE statements)
// - Exception handling (USE statement)
// - Controlling compiler listings (*CONTROL, *CBL, EJECT, TITLE, SKIP1, SKIP2,
//   and SKIP3 statements)
// - Specifying compiler options (CBL and PROCESS statements)
// - Specifying COBOL exception handling procedures (USE statements)
// The SERVICE LABEL statement is used with Language Environment condition
// handling. It is also generated by the CICS integrated translator (and the separate
// CICS translator).
// The following compiler directing statements have no effect: ENTER, READY or
// RESET TRACE, and SERVICE RELOAD.

compilerDirectingStatement ::= basisCompilerStatement 
/*
		| cblProcessCompilerStatement 
		| controlCblCompilerStatement 
		| copyCompilerStatement 
		| deleteCompilerStatement 
		| ejectCompilerStatement 
		| enterCompilerStatement 
		| execSqlIncludeStatement 
		| insertCompilerStatement 
		| readyOrResetTraceCompilerStatement 
		| replaceCompilerStatement 
		| serviceLabelCompilerStatement 
		| serviceReloadCompilerStatement 
		| skipCompilerStatement 
		| titleCompilerStatement
*/
		;

// p527: BASIS statement 
// The BASIS statement is an extended source text library statement. It provides a
// complete COBOL program as the source for a compilation.
// A complete program can be stored as an entry in a user-defined library and can be
// used as the source for a compilation. Compiler input is a BASIS statement,
// optionally followed by any number of INSERT and DELETE statements.
// sequence-number
// Can optionally appear in columns 1 through 6, followed by a space. The
// content of this field is ignored.
// BASIS
// >>> Can appear anywhere in columns 1 through 72, followed by basis-name.
// There must be no other text in the statement.
// basis-name, literal-1
// Is the name by which the library entry is known to the system
// environment.
// For rules of formation and processing rules, see the description under
// literal-1 and text-name of the “COPY statement” on page 530.
// The source file remains unchanged after execution of the BASIS statement.
// Usage note: If INSERT or DELETE statements are used to modify the COBOL
// source text provided by a BASIS statement, the sequence field of the COBOL
// source text must contain numeric sequence numbers in ascending order.

basisCompilerStatement ::=
                  /* sequenceNumber? */ BASIS:t textName:n
				  {: :}
				  ;



